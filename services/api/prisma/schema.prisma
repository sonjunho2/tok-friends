// services/api/prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  phoneHash      String?
  email          String?  @unique
  provider       String
  dob            DateTime
  gender         String
  region1        String?
  region2        String?
  lang           String?

  trustScore     Int      @default(50)
  status         String   @default("active")
  role           String   @default("user")
  passwordHash   String?
  displayName    String?

  profile        Profile?
  devices        Device[]
  photos         Photo[]
  friendshipsA   Friendship[] @relation("A")
  friendshipsB   Friendship[] @relation("B")
  chatsA         Chat[]       @relation("A")
  chatsB         Chat[]       @relation("B")
  messages       Message[]
  reportsByMe    Report[]     @relation("reports_by")
  reportsToMe    Report[]     @relation("reports_to")
  blocksByMe     Block[]      @relation("blocks_by")
  blocksToMe     Block[]      @relation("blocks_to")
  posts          Post[]
  subscriptions  Subscription[]
  events         AnalyticsEvent[]
  auditLogs      AuditLog[]   @relation("AuditActor")
  refundRequests RefundRequest[]
}

model Profile {
  userId     String  @id
  user       User    @relation(fields: [userId], references: [id])
  nickname   String
  bio        String?
  interests  String[]
  badges     String[]
  lastSeenAt DateTime?
  visibility Json?
}

model Photo {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  url         String
  visibility  String   @default("public")
  isSensitive Boolean  @default(false)
  aiNudity    Float    @default(0)
  createdAt   DateTime @default(now())
}

model Friendship {
  id          String   @id @default(cuid())
  requesterId String
  addresseeId String
  requester   User     @relation("A", fields: [requesterId], references: [id])
  addressee   User     @relation("B", fields: [addresseeId], references: [id])
  status      String   @default("requested")
  createdAt   DateTime @default(now())

  @@unique([requesterId, addresseeId])
}

model Chat {
  id            String   @id @default(cuid())
  userAId       String
  userBId       String
  userA         User     @relation("A", fields: [userAId], references: [id])
  userB         User     @relation("B", fields: [userBId], references: [id])
  lastMessageAt DateTime?
  messages      Message[]
}

model Message {
  id                 String   @id @default(cuid())
  chatId             String
  chat               Chat     @relation(fields: [chatId], references: [id])
  senderId           String
  sender             User     @relation(fields: [senderId], references: [id])
  type               String   @default("text")
  content            String
  translatedContent  String?
  createdAt          DateTime @default(now())
  isFlagged          Boolean  @default(false)
}

model Topic {
  id        String   @id @default(cuid())
  name      String   @unique
  createdAt DateTime @default(now())
  posts     Post[]
}

model Post {
  id        String   @id @default(cuid())
  userId    String
  topicId   String
  content   String   @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user    User     @relation(fields: [userId], references: [id])
  topic   Topic    @relation(fields: [topicId], references: [id])
  reports Report[]

  @@index([topicId, createdAt])
}

model Report {
  id           String   @id @default(cuid())
  reporterId   String
  targetUserId String?
  postId       String?
  reason       String
  createdAt    DateTime @default(now())

  reporter   User  @relation("reports_by", fields: [reporterId], references: [id])
  targetUser User? @relation("reports_to", fields: [targetUserId], references: [id])
  post       Post? @relation(fields: [postId], references: [id])
  messageId String?           // 채팅 메시지 신고시 연결용(선택)
  status    String? @default("PENDING") // 혹은 enum으로 설계해도 됨
  createdAt  DateTime @default(now())
}

model Block {
  id             String   @id @default(cuid())
  userId         String
  blockedUserId  String
  createdAt      DateTime @default(now())

  user        User @relation("blocks_by", fields: [userId], references: [id])
  blockedUser User @relation("blocks_to", fields: [blockedUserId], references: [id])

  @@unique([userId, blockedUserId])
}

model Device {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  platform  String
  token     String
  locale    String?
  createdAt DateTime @default(now())
}

model Subscription {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  platform  String
  productId String
  status    String
  startedAt DateTime
  expiresAt DateTime?
}

model AnalyticsEvent {
  id        String   @id @default(cuid())
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  event     String
  props     Json
  createdAt DateTime @default(now())
}

model AuditLog {
  id        String   @id @default(cuid())
  actorId   String?
  actor     User?    @relation("AuditActor", fields: [actorId], references: [id])
  target    String
  action    String
  notes     String?
  createdAt DateTime @default(now())
}

model RefundRequest {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  platform  String
  productId String
  receiptId String
  reason    String?
  status    String   @default("pending")
  createdAt DateTime @default(now())
  decidedAt DateTime?
}
